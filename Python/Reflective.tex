\section{Reflection and meta-programming}
\subsection{Reflective features}
\label{reflection}
% Q1
We can easily use reflection in Python with the following functions: type(), id(), isinstance(), callable(), dir(), getattr(), etc. \cite{python_doc_functions}.
The \textit{inspect} module can also be used to get information about objects \cite{python_doc_inspect}. Another module is the \textit{sys} module which allows us to query about the environment \cite{zetcode_introspection}.
The metaclass by default is the "type" object.

Here are some examples of such functions on the integer 42:
\lstinputlisting[language=Python]{code/dir_cut.py}

We can also create metaclasses: in Python, a metaclass can be a class, function or any object that supports calling an interface.

The syntax to use metaclasses has been modified from Python 2 to Python 3 \cite{mikewatkins_metaclasses}. The syntax of the metaclass' creation is still the same \cite{python_doc_datamodel}:
\lstinputlisting[language=Python]{code/metaclass.py}

Here is how to use a metaclass in Python 2:
\lstinputlisting[language=Python]{code/class_python2.py}
If you run this code under Python 3, the hook is not recognized: Python will just add a \_\_metaclass\_\_ attribute to the class but it will do nothing \cite{artima_metaclasses_1of2}.
\newline

Here is how to use a metaclass in Python 3:
\lstinputlisting[language=Python]{code/class_python3.py}

But if you want to have something which is compatible with both Python 2 and Python 3, you can use this:
\lstinputlisting[language=Python]{code/class_python2and3.py}

% Q2
We saw in the course that there are 2 parts of reflection: introspection which only looks at entities and intercession which can change the program behavior by manipulating the entities. % (part 2, slide 27)
Python performs the two.
\newline

Here is an example of intercession:
\lstinputlisting[language=Python]{code/intercession_resume.py}

% ----- Utile de décomposer pour la présentation :
%Here is an example of intercession:
%\lstinputlisting[language=Python]{code/intercession1.py}
%
%With the output:
%\lstinputlisting[language=Python]{code/intercession1_output.py}
%
%Now, we define a new method:
%\lstinputlisting[language=Python]{code/intercession2.py}
%
%We can do this:
%\lstinputlisting[language=Python]{code/intercession2_output.py}
%
%We want to modify the class A:
%\lstinputlisting[language=Python]{code/intercession3.py}
%
%Here is the final output:
%\lstinputlisting[language=Python]{code/intercession3_output.py}

We can also classify reflection according to what can be reflected: structural reflection and computational (behavioral) reflection. % (part 2, slide 29)
Python does both. It has a feature to add fields and methods to objects and classes. It can also modify the behavior of a method \cite{mendez2011computational}.

% Q3
In Python, it is possible to change the class of an object at runtime \cite{dynamic_lang_study}. % (related to become of Smalltalk).
Python MOP is about callables such as functions and instances with \_\_call\_\_ method \cite{Russel_MOP}.

% Q4
•	What are the limitations of the reflective features provided by this language?\\

% Q5: done within the other answers

\subsection{Applications of reflection}

Python is a perfect language to easily build various type of applications. 
Reflection seems to be omnipresent in this language. 
It is completely integrated in the way of programming in Python.\\

Most of the time, we need to know all details of methods associated with a class in order to enumerate these methods and print them. Several programming languages associate this structure with the type. In that case, the structure is defined by type and is already decided before run-time. Actually it is done most of the time during the compilation processus. For example, when you write a class in C++, you have to define all the details of this class. However, at run-time, the program itself is not aware of the structure of the class because it does not have the ability the examine its inner structure while the program is running.\\
One could say it is useless to examine this structure at run-time because it could have be done before. When writing it or even during an eventual compilation processus. But beside that, reflection is not only about the fact of examining its own structure. It is also the ability to modify and maintain its inner structure at run-time.\\
A program made in a programming language that does not support reflection is not able to call twice the same method in order to produce two different results depending on the inner structure of the program. In the opposite corner, a reflective programming language can do it. And some of them, such as Python, can achieve it easily due to their simple syntax. \cite{assembleforce} \\


This is Reflect.py defining the class \emph{reflect} that we will use to demonstrate reflective abilities of Python:
\lstinputlisting[language=Python]{code/demo/Reflect.py}

This is the main.py file that will be a reflection demonstration on the class \emph{reflect} :
\lstinputlisting[language=Python]{code/demo/main.py}

This is the output printed by main.py:
\lstinputlisting[language=Bash]{code/demo/output.sh}
Note that each line of this last file corresponds to the red comment number (\textcolor{red}{\#X}) in main.py.\\ 

The four first prints are applied on an instance $i$ of the class reflect from the file Reflect.py.\\
In the first print (\textcolor{red}{\#1}), we use .\_\_class\_\_ that refers to the class to which a class instance belongs. In this case the program asks to the instance $i$ to print its own class.\\
In the second print (\textcolor{red}{\#2}), .\_\_dict\_\_ is a descriptor object that returns the internal dictionary of attributes for a specific instance. In this case the program asks to the instance $i$ to print its internal dictionary of attributes.\\
In the third print (\textcolor{red}{\#3}), .\_\_doc\_\_ is the string of the class documentation. The class documentation of the file Reflect.py is the red comment line between the ''' symbols. This print straightforwardly asks $i$ to print a part of the file from the class which it is an instance.\\ 
In the fourth print (\textcolor{red}{\#4}), .\_\_sizeof\_\_ returns the size of an object in bytes. The instance $i$ prints its own size in bytes.\\

The fifth and sixth prints use accessors and mutators on the internal dictionary of attributes $d$ of the instance $i$.
In the fifth print (\textcolor{red}{\#5}), we use .\_\_getattribute\_\_('firstname') that will get the attribute value of the attribute called "firstname" in $d$. Thus, it prints Romain.
Before the sixth print (\textcolor{red}{\#6}), we modify the attribute values of the attributes "firstname" and "surname" to Antoine and Marchal respectively. If we now print the firstname of the instance $i$ (\textcolor{red}{\#6}), Antoine will be printed instead of Romain.\\

With \textcolor{red}{\#7}, we call the method \emph{welcome()} that simply prints the string "Welcome my friend!". Then, we link an attribute called \emph{hello} of the instance $i$ to that method \emph{welcome()}. Python use dynamic typing. This attribute will be defined as a method because the behaviour of \emph{welcome()} is the one of a method. This implies that calling \emph{i.hello()} (\textcolor{red}{\#8}) will actually call \emph{welcome()} and thus just as in \textcolor{red}{\#7} print the string "Welcome my friend!".\\

With \textcolor{red}{\#9}, we call the method message() that has been created at the creation of the instance $i$. The behaviour of this method on an instance $j$ is to print the string \emph{("My firstname is" + firstname + "and my surname is" + surname)} where the variables firstname and surname are $j$.\_\_getattribute\_\_(’firstname’) and $j$.\_\_getattribute\_\_(’surname’) respectively. Then, similarly to what we did before \textcolor{red}{\#8} we linked this attribute to the method welcome. This implies that calling \emph{i.message()} again (\textcolor{red}{\#10}) will actually call \emph{welcome()} and thus just as in \textcolor{red}{\#8} print the string "Welcome my friend!".\\

These four previous prints showed that it is possible and easy in Python to define are redefine dynamically typed attributes of an instance. As explained in \ref{reflection} this is called intercession and thus is a  simple and clear example of reflection in Python.\\

\subsubsection{Write a Quine}
To write a quine that makes use of reflection, we will divide our program in two parts:
\begin{enumerate}
    \item a string definition
    \item the program core
\end{enumerate}
The string contains the code of the program core and the program core will print this string twice. The first time to print the string and the second time to print the program core. The output of this program must be its source code.

This is the quine we wrote:
\lstinputlisting[language=Python]{code/quine.py}

To explain it, we modified the \emph{\_} symbols by variables \emph{a}, \emph{b}, \emph{c} and \emph{d} and we printed the output. This allows to understand directly that it has the same principle as a Matryoshka doll. The main doll is the source code that can be divided in two parts. In the program core and we can find inside (by printing) a smaller doll ; the string. And there is again a fourth doll in this string. The output of the program is a doll that has the same appearance than the original doll.
\lstinputlisting[language=Python]{code/quine_explained.py}

It is reflective because:
\begin{enumerate}
    \item The program is divided in two parts: string \& core.
    \item The core will print the string.
    \item The string is also divided in two parts: string \& core. Printed, it will produce a result that equals the source code. It is just like if the program was able to print itself. 
\end{enumerate}

\subsubsection{Python's killer-app : Youtube}

The creator of Python, Guido van Rossum works for Google. Python is used by Google for its search engine, Youtube, and other smaller Google products.\\

In 2006, Guido van Rossum said via the python developers mail list:
\emph{"And I just found out (after everyone else probably :-) that YouTube is almost entirely written in Python. (And now I can rub shoulders with the developers since they're all Googlers now... :-)"}\\

We do not have the code of these different Google products BUT if we look for this on the internet (using Google search engine of course), and if we draw aside video on Youtube about snakes, we can find the Python API in the Google developers website. For example, we can see that they use metaclasses, they even have modules called reflection (for example in the package protobuf). When loading a new message, the GeneratedProtocolMessageType metaclass uses intercession on the specified descriptors in order to create all the Python methods developers need to work with each message type and adds them to the relevant classes. \cite{google_reflection_references, google_reflection_tutorial}

This is an example from the google tutorial showing how to use reflection:
\lstinputlisting[language=Python]{code/demo/Google.py}


\subsection{Comparison with other languages}
•	How does this language compare to Smalltalk, Java or Ruby from the point of view of the reflective features it supports, the kinds of reflection it offers, or its MOP?\\
It seems that both languages allows a lot of possibilites in meta-programming but it is less common in Python than in Ruby. It is possible to realize the same things in Python or in Ruby.

•	What can this language learn from those languages?\\
•	Does it offer some specific reflective features that you do not have in either Smalltalk, Ruby or Java? (Can Smalltalk/Java learn something from reflection in this language?)\\
•	Does it offer some powerful native (non-reflective) features that allow you to express things for which you would need reflection in other languages (like Smalltalk, Ruby or Java)?\\
