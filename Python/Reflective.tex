\section{Reflection and meta-programming}
\subsection{Reflective features}
•	What language features for dealing with reflection and meta-programming does the chosen language provide?\\
•	What kinds of reflection and meta-programming features does that language offer?\\
•	What is the MOP (meta-object protocol) for that language?\\
•	What are the limitations of the reflective features provided by this language?\\
•	Illustrate your explanations with working code fragments.\\

\subsubsection{Write a Quine}
To write a quine that makes use of reflection, we will divide our program in two parts :
\begin{enumerate}
    \item a string definition
    \item the program core
\end{enumerate}
The string contains the code of the program core and the program core will print twice this string. Once to print the string, and again to print the program core. The output of this program must its source code.


This is the quine we wrote :
\lstinputlisting[language=Python]{code/quine.py}

To explain it, we modified the \emph{\_} symbols by variables \emph{a}, \emph{b}, \emph{c} and \emph{d} and printed the output. This allows to understand directly that it has the same principle as a Matryoshka doll. The main doll is the source code that can be divided in two parts. In the program core and we can find inside (by printing) a smaller doll ; the string. And there is again a fourth doll in this string. The output of the program is a doll that has the same appearance than the original doll.
\lstinputlisting[language=Python]{code/quine_explained.py}

It is reflective because :
\begin{enumerate}
    \item the program is divided in two parts; string \& core
    \item the core will print the string.
    \item the string is also divided in two parts; string \& core and printed, it will produce a result that equals the source code. It is just like the program was able to print itself. 
\end{enumerate}

\subsection{Applications of reflection}
•	What are the typical applications that reflection could be used for in this language?\\

We need to know all details of methods associated with a class in order to enumerate these methods and print them. Several programming languages associate this structure with the type. In that case, the structure is defined by type and is already decided before run-time. Actually it is done most of the time during the compilation processus. For example, when you write a class in C++, you have to define all the details of this class. However, at run-time, the program itself is not aware of the structure of the class because it does not have the ability the examine its inner structure while the program is running.\\
One could say it is useless to examine this structure at run-time because he could have done it before. When writing it or even during an eventual compilation processus. But beside that, reflection is not only about the fact of examining its own structure. It is also the ability to modify and maintain its inner structure at run-time.\\
A program made in a programming language that does not support reflection is not able to call twice the same method in order to produce two different results depending on the inner structure of the program. In the opposite corner, a reflective programming language can do it. And some of them, such as Python, can achieve it easily due to their simple syntax. \cite{assembleforce}
\newline


•	Can you give a working code example of such a typical problem that requires a reflective solution?\\
\lstinputlisting[language=Python]{code/demo/Reflect.py}

\lstinputlisting[language=Python]{code/demo/main.py}

\lstinputlisting[language=Bash]{code/demo/output.sh}


•	Does there exist a “killer-app” for this language that has been implemented with reflection?\\

\subsection{Comparison with other languages}
•	How does this language compare to Smalltalk, Java or Ruby from the point of view of the reflective features it supports, the kinds of reflection it offers, or its MOP?\\
•	What can this language learn from those languages?\\
•	Does it offer some specific reflective features that you do not have in either Smalltalk, Ruby or Java? (Can Smalltalk/Java learn something from reflection in this language?)\\
•	Does it offer some powerful native (non-reflective) features that allow you to express things for which you would need reflection in other languages (like Smalltalk, Ruby or Java)?\\
