\section{Reflection and meta-programming}
\subsection{Reflective features}
•	What language features for dealing with reflection and meta-programming does the chosen language provide?\\
•	What kinds of reflection and meta-programming features does that language offer?\\
•	What is the MOP (meta-object protocol) for that language?\\
•	What are the limitations of the reflective features provided by this language?\\
•	Illustrate your explanations with working code fragments.\\

\subsubsection{Write a Quine}
To write a quine that makes use of reflection, we will divide our program in two parts :
\begin{enumerate}
    \item a string definition
    \item the program core
\end{enumerate}
The string contains the code of the program core and the program core will print twice this string. Once to print the string, and again to print the program core. The output of this program must its source code.


This is the quine we wrote :
\lstinputlisting[language=Python]{code/quine.py}

To explain it, we modified the \emph{\_} symbols by variables \emph{a}, \emph{b}, \emph{c} and \emph{d} and printed the output. This allows to understand directly that it has the same principle as a Matryoshka doll. The main doll is the source code that can be divided in two parts. In the program core and we can find inside (by printing) a smaller doll ; the string. And there is again a fourth doll in this string. The output of the program is a doll that has the same appearance than the original doll.
\lstinputlisting[language=Python]{code/quine_explained.py}

It is reflective because :
\begin{enumerate}
    \item the program is divided in two parts; string \& core
    \item the core will print the string.
    \item the string is also divided in two parts; string \& core and printed, it will produce a result that equals the source code. It is just like the program was able to print itself. 
\end{enumerate}

\subsection{Applications of reflection}
•	What are the typical applications that reflection could be used for in this language?\\

\emph{"Reflection of a programming language is the ability to examine, modify and maintain its inner structure by the programming language itself at runtime.\\
For example, if I write a class and I want to enumerate all the methods and print them to a file, I will need to know the exact set of methods associated with this class. Not that this structure is associated with the type, but not the instance.\\ For the association with type, I mean the structure is defined by type and is already decided before the program runs. A live example can be C++. When you write a class in C++, you know all the details of this C++ class. However, when the program runs, the program itself is not aware of the structure of the class because it is lack of the ability the examine its inner structure at runtime.\\
Of course, you can say you don’t need to examine its structure at runtime because you already knew it when writing this class. But how you can modify the structure remains unsolved.\\
For example, if you want to call method A(), and then call it again except that we expect a different behaviour at your second calling to that method. How can C++ achieve this? It can’t. But with Python, you can do this easily."} \cite{assembleforce}

•	Can you give a working code example of such a typical problem that requires a reflective solution?\\
\lstinputlisting[language=Python]{code/demo/Reflect.py}

\lstinputlisting[language=Python]{code/demo/main.py}

\lstinputlisting[language=Bash]{code/demo/output.sh}


•	Does there exist a “killer-app” for this language that has been implemented with reflection?\\

\subsection{Comparison with other languages}
•	How does this language compare to Smalltalk, Java or Ruby from the point of view of the reflective features it supports, the kinds of reflection it offers, or its MOP?\\
•	What can this language learn from those languages?\\
•	Does it offer some specific reflective features that you do not have in either Smalltalk, Ruby or Java? (Can Smalltalk/Java learn something from reflection in this language?)\\
•	Does it offer some powerful native (non-reflective) features that allow you to express things for which you would need reflection in other languages (like Smalltalk, Ruby or Java)?\\
